## คำถามสำหรับวิเคราะห์

1. Task ไหนใช้ stack มากที่สุด? เพราะอะไร?
คำตอบ:
Task ที่มี ตัวแปรภายใน (local variables) จำนวนมาก หรือมี การคำนวณซับซ้อน เช่น ใช้การเรียกฟังก์ชันซ้อนกันหลายชั้น จะใช้ stack มากที่สุด
เพราะ Stack ถูกใช้เก็บตัวแปรภายใน, ตัวชี้กลับ (return address) และข้อมูลชั่วคราวในแต่ละฟังก์ชัน
สรุป:
Task ที่มีฟังก์ชันลึกและตัวแปรภายในมาก = ใช้ stack มาก
2. การใช้ heap แทน stack มีข้อดีอย่างไร?
คำตอบ:
Heap เป็นหน่วยความจำแบบ dynamic allocation (จองและคืนได้ระหว่างรันไทม์)
ข้อดีคือสามารถจัดการหน่วยความจำให้ ยืดหยุ่นกว่า stack โดยเฉพาะในกรณีที่ต้องสร้าง buffer หรือ object ที่ขนาดไม่แน่นอน
สรุปข้อดี:
จองหน่วยความจำได้เมื่อจำเป็น (ประหยัด RAM)
ใช้สร้างโครงสร้างข้อมูลที่ขนาดเปลี่ยนได้
ไม่เสี่ยง overflow เท่า stack หากจัดการดี
3. Stack overflow เกิดขึ้นเมื่อไหร่ และทำอย่างไรป้องกัน?
คำตอบ:
เกิดขึ้นเมื่อ Task ใช้หน่วยความจำ stack เกินขนาดที่กำหนดใน xTaskCreate()
เช่น มีการเรียกฟังก์ชันซ้อนมากเกินไป หรือประกาศตัวแปรขนาดใหญ่ภายใน Task
วิธีป้องกัน:
กำหนด stack size ให้เพียงพอต่อการใช้งานจริง
เปิดการตรวจจับใน FreeRTOSConfig.h:
#define configCHECK_FOR_STACK_OVERFLOW 2
ใช้ uxTaskGetStackHighWaterMark() เพื่อตรวจสอบการใช้ stack ระหว่างรัน
4. การตั้งค่า stack size ควรพิจารณาจากอะไร?
คำตอบ:
ควรพิจารณาจาก
จำนวนและขนาดของตัวแปรภายใน Task
ระดับความลึกของการเรียกฟังก์ชัน (call depth)
การใช้ library ที่อาจใช้ stack ภายใน เช่น printf(), sprintf()
สรุป:
ตั้งค่า stack size ตามความซับซ้อนของ Task → ยิ่ง Task ซับซ้อนมาก ต้องใช้ stack มาก
5. Recursion ส่งผลต่อ stack usage อย่างไร?
คำตอบ:
Recursion (การเรียกฟังก์ชันซ้ำตัวเอง) ใช้ stack จำนวนมาก
เพราะทุกครั้งที่เรียกซ้ำ ระบบต้องเก็บ context (ตัวแปรภายใน + return address) แยกไว้ใน stack
ถ้า recursion ลึกเกินไป → อาจทำให้ stack overflow ได้
สรุป:
Recursion เพิ่มการใช้ stack แบบทวีคูณ ควรหลีกเลี่ยงใน embedded system ที่ stack จำกัด